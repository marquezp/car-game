extends RigidBody2D
@onready var car: RigidBody2D = $"."
@onready var click_box: Area2D = $ClickBox
@onready var charge_up: Label = $ChargeUp
@export var max_charge = 100 # TODO mess around with this variable when playtesting

var selected = false
var damping_factor = 0
var is_slowing_down: bool = false
var wheels = []
var current_charge: float = 0.0

func start_slowing_down(rate):
	damping_factor = rate
	is_slowing_down = true
		
func stop_slowing_down():
	is_slowing_down = false

func _ready():
	# add the wheels to an array
	wheels = get_tree().get_nodes_in_group("wheel")
	# connections
	click_box.input_event.connect(_on_click_box_input_event)
	click_box.mouse_entered.connect(_on_click_box_mouse_entered)
	click_box.mouse_exited.connect(_on_click_box_mouse_exited)


# Cursor hovering on car
func _on_click_box_mouse_entered() -> void:
	print("entered")
	if not selected:
		Input.set_default_cursor_shape(Input.CURSOR_POINTING_HAND)

# Cursor no longer hovering on car
func _on_click_box_mouse_exited() -> void:
	# Only change cursor if we haven't clicked yet
	print("exited")
	if not selected:
		Input.set_default_cursor_shape(Input.CURSOR_ARROW)

# car body area has been clicked, logic handled in physics_process
func _on_click_box_input_event(viewport: Node, event: InputEvent, shape_idx: int) -> void:
	if Input.is_action_just_pressed("click"):
		selected = true

# Apply the charge generated by the drag-back as torque on the wheels
func move_car(charge):
	for wheel in wheels:
		wheel.apply_torque_impulse(charge * 200)
	
	current_charge = 0
	Input.set_default_cursor_shape(Input.CURSOR_ARROW)

# This function handles global inputs
func _input(event):
	# mouse button released
	if selected and event is InputEventMouseButton:
		if (event.button_index == MOUSE_BUTTON_LEFT and not event.pressed):
			selected = false # stops the car from following the cursor
			if current_charge < max_charge:
				move_car(current_charge)

func _physics_process(delta: float) -> void:
	# Handle mouse click to CHARGE UP THE CAR
	if selected:
		current_charge = min(current_charge + (50 * delta), max_charge)
		
		for wheel in wheels:
			wheel.get_node("AnimationPlayer").play("charge_up")

	# Charge goes over limit
	if current_charge >= max_charge:
		selected = false
		move_car(current_charge)
	
	# Check for carpet
	if is_slowing_down:
		for wheel in wheels:
			wheel.angular_velocity *= 0.9
			
	# Display debug info
	charge_up.text = "Charge: " + str(int(current_charge))
