extends RigidBody2D
@onready var car: RigidBody2D = $"."
@onready var click_box: Area2D = $ClickBox
@onready var distance_label: Label = $DistanceLabel
@onready var linear_velocity_label: Label = $LinearVelocityLabel
@export var max_distance = 100 #TODO mess around with this variable when playtesting

var selected = false
var damping_factor = 0
var is_slowing_down: bool = false
var wheels = []
var previous_position: Vector2
var distance_traveled: float = 0.0

func start_slowing_down(rate):
	damping_factor = rate
	is_slowing_down = true
		
func stop_slowing_down():
	is_slowing_down = false

func _ready():
	# add the wheels to an array
	wheels = get_tree().get_nodes_in_group("wheel")
	previous_position = click_box.global_position

# car body area has been clicked, logic handled in physics_process
func _on_click_box_input_event(viewport: Node, event: InputEvent, shape_idx: int) -> void:
	if Input.is_action_just_pressed("click"):
		selected = true

# Apply the charge generated by the drag-back as torque on the wheels
func move_car(distance):
	for wheel in wheels:
		wheel.apply_torque(distance * 20000)
	distance_traveled = 0

# This function handles global inputs
func _input(event):
	# mouse button released
	if selected and event is InputEventMouseButton:
		if (event.button_index == MOUSE_BUTTON_LEFT and not event.pressed):
			selected = false # stops the car from following the cursor
			move_car(distance_traveled)
			
func _physics_process(delta: float) -> void:
	# Handle mouse click and drag to CHARGE UP THE CAR
	# make sure it only drags backwards
	if selected and (get_global_mouse_position().x < click_box.global_position.x): 
		var mouse_target = get_global_mouse_position()
		
		# increment the distance traveled in the frame
		distance_traveled += abs(click_box.global_position.x - previous_position.x)
		previous_position = click_box.global_position
		
		# move the car and wheel model backwards
		car.global_position.x = move_toward(car.global_position.x, mouse_target.x, delta * 25 )
		for wheel in wheels:
			wheel.global_position.x = move_toward(wheel.global_position.x, mouse_target.x , delta * 25)
			
			
	# Charge goes over limit
	if distance_traveled >= max_distance:
		selected = false
		move_car(distance_traveled)
	
	# Check for carpet
	if is_slowing_down:
		for wheel in wheels:
			wheel.angular_velocity *= 0.9
			
	# Display debug info
	distance_label.text = "Distance Traveled: " + str(int(distance_traveled))
	linear_velocity_label.text = "Linear Vel: " + str(car.linear_velocity.x)
	
	
