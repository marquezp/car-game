extends RigidBody2D
@onready var car: RigidBody2D = $"."
@onready var click_box: Area2D = $ClickBox
@onready var distance_label: Label = $DistanceLabel
@onready var linear_velocity_label: Label = $LinearVelocityLabel
@export var max_distance = 100 #TODO mess around with this variable when playtesting

var selected = false
var damping_factor = 0
var is_slowing_down: bool = false
var wheels = []

var previous_position: Vector2
var distance_traveled: float = 0.0
var wheel_circumference = 2 * PI * 10 # wheel circumference, dont @ me for hardcoding
var torque_strength = -1000

# TESTING VARIABLES


func start_slowing_down(rate):
	damping_factor = rate
	is_slowing_down = true
		
func stop_slowing_down():
	is_slowing_down = false

func _ready():
	# add the wheels to an array
	wheels = get_tree().get_nodes_in_group("wheel")
	previous_position = click_box.global_position

# car body area has been clicked, logic handled in physics_process
func _on_click_box_input_event(viewport: Node, event: InputEvent, shape_idx: int) -> void:
	if Input.is_action_just_pressed("click"):
		selected = true

# Apply the charge generated by the drag as torque inpulse on the wheels
func move_car(distance):
	for wheel in wheels:
		wheel.apply_torque(distance * 20000)
	distance_traveled = 0

func stop_car():
	for wheel in wheels:
		wheel.apply_torque(0)
		wheel.angular_velocity *= 0.5
	
# This function handles global inputs
func _input(event):
	# mouse button released
	if selected and event is InputEventMouseButton:
		if (event.button_index == MOUSE_BUTTON_LEFT and not event.pressed):
			selected = false # stops the car from following the cursor
			move_car(distance_traveled)
			
func _physics_process(delta: float) -> void:
	# Handle mouse click and drag to CHARGE UP THE CAR
	if selected:
		if (get_global_mouse_position().x < click_box.global_position.x): # make sure it only drags backwards
			var mouse_target = get_global_mouse_position() - click_box.global_position
			
			# Calculate the rotation needed to move the wheels that distance
			var rotations_to_make = abs(mouse_target.x) / wheel_circumference
			var target_radians = rotations_to_make * 2 * PI
			
			# increment the distance traveled in the frame
			distance_traveled += abs(click_box.global_position.x - previous_position.x)
			previous_position = click_box.global_position
			
			# Move or stop the car depending on if we reached the mouse_target
			for wheel in wheels:
				if (abs(wheel.rotation) < target_radians) and distance_traveled < max_distance:
					wheel.apply_torque(torque_strength)  
				else:
					if distance_traveled < max_distance: 
						stop_car()
			
		else:
			stop_car()
			
	# Charge goes over limit
	if distance_traveled >= max_distance:
		selected = false
		move_car(distance_traveled)
	
	# Check for carpet
	if is_slowing_down:
		for wheel in wheels:
			wheel.angular_velocity *= 0.9
			
	# Display debug info
	distance_label.text = "Distance Traveled: " + str(int(distance_traveled))
	linear_velocity_label.text = "Linear Vel: " + str(car.linear_velocity.x)
	
	
